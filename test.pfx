$def nil [];

$def true #t;
$def false #f;

$def not:a $if a false true;

$def || a b
	$if = a true
		true
		$if = b true
			true
			false;

$memdef && a b not:|| not:a not:b;

$def sub: a b + a -b;

$def > a b not:<= a b;
$def < a b && not:= a b <= a b;
$def >= a b not:< a b;

$def my_head:[hd .._]
	hd;

$def my_tail:[_ ..tail]
	tail;

$memdef ^ x exp
	$if = exp 0
		1
		* x ^ x sub: exp 1;

$memdef \any any;

$def nth_fib:n (
	$if = n 0
		1
		$if = n 1
			1
			+ nth_fib:sub: n 1 nth_fib:sub: n 2
);

$def is_even:n
	= 0 % n 2;

$memdef range: min max
	$if = min max
		[]
		cons: min range: + min 1 max;

$def map: _ [] [];
$memdef map: fn [hd ..rest]
	cons: fn:hd map: fn rest;

$def len:[] 0;
$memdef len:[_ ..rest]
	+ 1 len:rest;

$memdef filter: fn list
	$if = list nil
		nil
		(
			$def hd head:list;

			$if fn:hd
				cons: hd filter: fn tail:list
				filter: fn tail:list
		);

$memdef flip:fn
	$fn a b fn: b a;

$memdef ,func
	$fn a [a func:a];

$memdef . fn_a fn_b
	$fn x fn_a:fn_b:x;

$memdef @ fn param
	$fn x fn: param x;

$memdef apply: fn param
	fn:param;

$def do_print:a
	print:a;

$memdef !! i list
	$if = i 0
		head:list
		!! sub: i 1 tail:list;

$def hash_get: [] key
	#none;

$def hash_get: [[k v] ..rest] key
	$if = k key
		v
		hash_get: rest key;

$def memoize_unary:fn (
	$def memo mut.[];

	$fn a (
		$def stored hash_get: !memo a;
		$if = stored #none
			(
				$def out fn:a;
				set! memo cons: [a out] memo;
				out
			)
			stored
	)
);

$def empty:[.._] #f;
$def empty:[] #t;

$def memfib memoize_unary:nth_fib;

print:memfib:20;
print:memfib:20;
print:memfib:20;
print:memfib:20
